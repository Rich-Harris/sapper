'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var sander = require('sander');
var path = require('path');
var glob = require('glob');
var glob__default = _interopDefault(glob);
var __chunk_2 = require('./chunk-0b33a300.js');
var relative = _interopDefault(require('require-relative'));

var previous_contents = new Map();
function write_if_changed(file, code) {
    if (code !== previous_contents.get(file)) {
        previous_contents.set(file, code);
        sander.writeFileSync(file, code);
        fudge_mtime(file);
    }
}
function posixify(file) {
    return file.replace(/[/\\]/g, '/');
}
function fudge_mtime(file) {
    // need to fudge the mtime so that webpack doesn't go doolally
    var _a = sander.statSync(file), atime = _a.atime, mtime = _a.mtime;
    sander.utimesSync(file, new Date(atime.getTime() - 999999), new Date(mtime.getTime() - 999999));
}

function create_main_manifests(_a) {
    var routes = _a.routes, dev_port = _a.dev_port;
    var path_to_routes = path.relative(__chunk_2.locations.app() + "/manifest", __chunk_2.locations.routes());
    var client_manifest = generate_client(routes, path_to_routes, dev_port);
    var server_manifest = generate_server(routes, path_to_routes);
    write_if_changed(__chunk_2.locations.app() + "/manifest/client.js", client_manifest);
    write_if_changed(__chunk_2.locations.app() + "/manifest/server.js", server_manifest);
}
function create_serviceworker_manifest(_a) {
    var routes = _a.routes, client_files = _a.client_files;
    var assets = glob.sync('**', { cwd: 'assets', nodir: true });
    var code = ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\texport const timestamp = " + Date.now() + ";\n\n\t\texport const assets = [\n\t" + assets.map(function (x) { return "\"" + x + "\""; }).join(',\n\t') + "\n];\n\n\t\texport const shell = [\n\t" + client_files.map(function (x) { return "\"" + x + "\""; }).join(',\n\t') + "\n];\n\n\t\texport const routes = [\n\t" + routes.filter(function (r) { return r.type === 'page' && !/^_[45]xx$/.test(r.id); }).map(function (r) { return "{ pattern: " + r.pattern + " }"; }).join(',\n\t') + "\n];\n\t").replace(/^\t\t/gm, '').trim();
    write_if_changed(__chunk_2.locations.app() + "/manifest/service-worker.js", code);
}
function generate_client(routes, path_to_routes, dev_port) {
    var code = ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\texport const routes = [\n\t\t\t" + routes
        .map(function (route) {
        var page = route.handlers.find(function (_a) {
            var type = _a.type;
            return type === 'page';
        });
        if (!page) {
            return "{ pattern: " + route.pattern + ", ignore: true }";
        }
        var file = posixify(path_to_routes + "/" + page.file);
        if (route.id === '_4xx' || route.id === '_5xx') {
            return "{ error: '" + route.id.slice(1) + "', load: () => import(/* webpackChunkName: \"" + route.id + "\" */ '" + file + "') }";
        }
        var params = route.params.length === 0
            ? '{}'
            : "{ " + route.params.map(function (part, i) { return part + ": match[" + (i + 1) + "]"; }).join(', ') + " }";
        return "{ pattern: " + route.pattern + ", params: " + (route.params.length > 0 ? "match" : "()") + " => (" + params + "), load: () => import(/* webpackChunkName: \"" + route.id + "\" */ '" + file + "') }";
    })
        .join(',\n\t') + "\n\t\t];").replace(/^\t\t/gm, '').trim();
    if (__chunk_2.dev()) {
        var sapper_dev_client = posixify(path.resolve(__dirname, '../sapper-dev-client.js'));
        code += ("\n\n\t\t\tif (module.hot) {\n\t\t\t\timport('" + sapper_dev_client + "').then(client => {\n\t\t\t\t\tclient.connect(" + dev_port + ");\n\t\t\t\t});\n\t\t\t}").replace(/^\t{3}/gm, '');
    }
    return code;
}
function generate_server(routes, path_to_routes) {
    var code = ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\t" + routes
        .map(function (route) {
        return route.handlers
            .map(function (_a, index) {
            var type = _a.type, file = _a.file;
            var module = posixify(path_to_routes + "/" + file);
            return type === 'page'
                ? "import " + route.id + index + " from '" + module + "';"
                : "import * as " + route.id + index + " from '" + module + "';";
        })
            .join('\n');
    })
        .join('\n') + "\n\n\t\texport const routes = [\n\t\t\t" + routes
        .map(function (route) {
        var handlers = route.handlers
            .map(function (_a, index) {
            var type = _a.type;
            return "{ type: '" + type + "', module: " + route.id + index + " }";
        })
            .join(', ');
        if (route.id === '_4xx' || route.id === '_5xx') {
            return "{ error: '" + route.id.slice(1) + "', handlers: [" + handlers + "] }";
        }
        var params = route.params.length === 0
            ? '{}'
            : "{ " + route.params.map(function (part, i) { return part + ": match[" + (i + 1) + "]"; }).join(', ') + " }";
        return "{ id: '" + route.id + "', pattern: " + route.pattern + ", params: " + (route.params.length > 0 ? "match" : "()") + " => (" + params + "), handlers: [" + handlers + "] }";
    })
        .join(',\n\t') + "\n\t\t];").replace(/^\t\t/gm, '').trim();
    return code;
}

function create_compilers(_a) {
    var webpack = _a.webpack;
    var wp = relative('webpack', process.cwd());
    var serviceworker_config = try_require(path.resolve(webpack + "/service-worker.config.js"));
    return {
        client: wp(require(path.resolve(webpack + "/client.config.js"))),
        server: wp(require(path.resolve(webpack + "/server.config.js"))),
        serviceworker: serviceworker_config && wp(serviceworker_config)
    };
}
function try_require(specifier) {
    try {
        return require(specifier);
    }
    catch (err) {
        if (err.code === 'MODULE_NOT_FOUND')
            return null;
        throw err;
    }
}

function create_routes(_a) {
    var files = (_a === void 0 ? { files: glob__default.sync('**/*.*', { cwd: __chunk_2.locations.routes(), dot: true, nodir: true }) } : _a).files;
    var routes = files
        .filter(function (file) { return !/(^|\/|\\)_/.test(file); })
        .map(function (file) {
        if (/(^|\/|\\)(_|\.(?!well-known))/.test(file))
            return;
        if (/]\[/.test(file)) {
            throw new Error("Invalid route " + file + " \u2014 parameters must be separated");
        }
        var base = file.replace(/\.[^/.]+$/, '');
        var parts = base.split('/'); // glob output is always posix-style
        if (parts[parts.length - 1] === 'index')
            parts.pop();
        return {
            files: [file],
            base: base,
            parts: parts
        };
    })
        .filter(Boolean)
        .filter(function (a, index, array) {
        var _a;
        var found = array.slice(index + 1).find(function (b) { return a.base === b.base; });
        if (found)
            (_a = found.files).push.apply(_a, a.files);
        return !found;
    })
        .sort(function (a, b) {
        if (a.parts[0] === '4xx' || a.parts[0] === '5xx')
            return -1;
        if (b.parts[0] === '4xx' || b.parts[0] === '5xx')
            return 1;
        var max = Math.max(a.parts.length, b.parts.length);
        for (var i = 0; i < max; i += 1) {
            var a_part = a.parts[i];
            var b_part = b.parts[i];
            if (!a_part)
                return -1;
            if (!b_part)
                return 1;
            var a_sub_parts = get_sub_parts(a_part);
            var b_sub_parts = get_sub_parts(b_part);
            var max_1 = Math.max(a_sub_parts.length, b_sub_parts.length);
            for (var i_1 = 0; i_1 < max_1; i_1 += 1) {
                var a_sub_part = a_sub_parts[i_1];
                var b_sub_part = b_sub_parts[i_1];
                if (!a_sub_part)
                    return 1; // b is more specific, so goes first
                if (!b_sub_part)
                    return -1;
                if (a_sub_part.dynamic !== b_sub_part.dynamic) {
                    return a_sub_part.dynamic ? 1 : -1;
                }
                if (!a_sub_part.dynamic && a_sub_part.content !== b_sub_part.content) {
                    return ((b_sub_part.content.length - a_sub_part.content.length) ||
                        (a_sub_part.content < b_sub_part.content ? -1 : 1));
                }
            }
        }
        throw new Error("The " + a.base + " and " + b.base + " routes clash");
    })
        .map(function (_a) {
        var files = _a.files, base = _a.base, parts = _a.parts;
        var id = (parts.join('_').replace(/[[\]]/g, '$').replace(/^\d/, '_$&').replace(/[^a-zA-Z0-9_$]/g, '_')) || '_';
        var params = [];
        var param_pattern = /\[([^\]]+)\]/g;
        var match;
        while (match = param_pattern.exec(base)) {
            params.push(match[1]);
        }
        // TODO can we do all this with sub-parts? or does
        // nesting make that impossible?
        var pattern_string = '';
        var i = parts.length;
        var nested = true;
        while (i--) {
            var part = encodeURI(parts[i].normalize()).replace(/\?/g, '%3F').replace(/#/g, '%23').replace(/%5B/g, '[').replace(/%5D/g, ']');
            var dynamic = ~part.indexOf('[');
            if (dynamic) {
                var matcher = part.replace(param_pattern, "([^/]+?)");
                pattern_string = nested ? "(?:\\/" + matcher + pattern_string + ")?" : "\\/" + matcher + pattern_string;
            }
            else {
                nested = false;
                pattern_string = "\\/" + part + pattern_string;
            }
        }
        var pattern = new RegExp("^" + pattern_string + "\\/?$");
        var test = function (url) { return pattern.test(url); };
        var exec = function (url) {
            var match = pattern.exec(url);
            if (!match)
                return;
            var result = {};
            params.forEach(function (param, i) {
                result[param] = match[i + 1];
            });
            return result;
        };
        return {
            id: id,
            handlers: files.map(function (file) { return ({
                type: path.extname(file) === '.html' ? 'page' : 'route',
                file: file
            }); }).sort(function (a, b) {
                if (a.type === 'page' && b.type === 'route') {
                    return 1;
                }
                if (a.type === 'route' && b.type === 'page') {
                    return -1;
                }
                return 0;
            }),
            pattern: pattern,
            test: test,
            exec: exec,
            parts: parts,
            params: params
        };
    });
    return routes;
}
function get_sub_parts(part) {
    return part.split(/[\[\]]/)
        .map(function (content, i) {
        if (!content)
            return null;
        return {
            content: content,
            dynamic: i % 2 === 1
        };
    })
        .filter(Boolean);
}

exports.create_compilers = create_compilers;
exports.create_routes = create_routes;
exports.create_main_manifests = create_main_manifests;
exports.create_serviceworker_manifest = create_serviceworker_manifest;
//# sourceMappingURL=core.ts.js.map
